import {
  GeneratedInsight,
  NPSData,
  NPSResponse,
  CSATData,
  CSATResponse,
  CESData,
  CESResponse,
  InterviewData,
  InterviewHighlight,
  SurveyData,
  SurveyResponse,
  InsightSource,
  ImportResult,
} from '@/types/insight-import'
import { Evidence, JourneyMapData } from '@/types/journey-map'
import { callOpenRouter, parseAIJsonResponse } from './openRouter'

/**
 * InsightGenerator - Transforms research data into structured insights
 *
 * This service takes raw research data (NPS, CSAT, CES, interviews, surveys)
 * and converts it into structured insights with evidence, severity scores,
 * and auto-generated titles.
 */
export class InsightGenerator {
  private journeyId: string
  private journeyMap?: JourneyMapData

  constructor(journeyId: string, journeyMap?: JourneyMapData) {
    this.journeyId = journeyId
    this.journeyMap = journeyMap
  }

  /**
   * Generate insights from NPS data
   * Focus on detractors (score 0-6) and passives (score 7-8)
   */
  async generateFromNPS(npsData: NPSData): Promise<GeneratedInsight[]> {
    const insights: GeneratedInsight[] = []

    // Process detractors (0-6) - high severity
    const detractors = npsData.responses.filter(r => r.score <= 6 && r.comment)
    for (const response of detractors) {
      if (!response.comment) continue

      const insight = await this.createInsightFromNPSResponse(
        response,
        npsData,
        this.calculateNPSSeverity(response.score)
      )
      insights.push(insight)
    }

    // Process passives (7-8) - medium severity
    const passives = npsData.responses.filter(r => r.score >= 7 && r.score <= 8 && r.comment)
    for (const response of passives) {
      if (!response.comment) continue

      const insight = await this.createInsightFromNPSResponse(
        response,
        npsData,
        this.calculateNPSSeverity(response.score)
      )
      insights.push(insight)
    }

    return insights
  }

  private async createInsightFromNPSResponse(
    response: NPSResponse,
    npsData: NPSData,
    severity: 1 | 2 | 3 | 4 | 5
  ): Promise<GeneratedInsight> {
    // Use AI to extract better title and summary
    const aiExtraction = await this.extractInsightWithAI(
      response.comment || '',
      { type: 'NPS', score: response.score }
    )

    const evidence: Evidence[] = [{
      id: `evidence-${response.id}`,
      source: npsData.campaignName || 'NPS Survey',
      type: 'verbatim',
      text: response.comment,
      value: response.score,
      unit: 'nps-score',
      collected_at: response.date
    }]

    const source: InsightSource = {
      type: 'nps',
      sourceId: npsData.id,
      sourceName: npsData.campaignName || 'NPS Survey',
      autoGenerated: true
    }

    return {
      tempId: `temp-${Date.now()}-${Math.random()}`,
      journey_id: this.journeyId,
      title: aiExtraction.title,
      summary: aiExtraction.summary,
      severity: aiExtraction.severity,
      evidence,
      source,
      suggestedPlacements: [], // Will be filled by InsightMatcher
      autoGenerated: true,
      generationMethod: aiExtraction.method
    }
  }

  /**
   * Generate insights from CSAT data
   * Focus on low scores (1-2) and medium scores (3)
   */
  async generateFromCSAT(csatData: CSATData): Promise<GeneratedInsight[]> {
    const insights: GeneratedInsight[] = []

    // Process low scores (1-2) - high severity
    const lowScores = csatData.responses.filter(r => r.score <= 2 && r.comment)
    for (const response of lowScores) {
      if (!response.comment) continue

      const insight = this.createInsightFromCSATResponse(
        response,
        csatData,
        response.score === 1 ? 5 : 4
      )
      insights.push(insight)
    }

    // Process medium scores (3) - medium severity
    const mediumScores = csatData.responses.filter(r => r.score === 3 && r.comment)
    for (const response of mediumScores) {
      if (!response.comment) continue

      const insight = this.createInsightFromCSATResponse(
        response,
        csatData,
        3
      )
      insights.push(insight)
    }

    return insights
  }

  private createInsightFromCSATResponse(
    response: CSATResponse,
    csatData: CSATData,
    severity: 1 | 2 | 3 | 4 | 5
  ): GeneratedInsight {
    const title = this.extractTitle(response.comment || '')

    const evidence: Evidence[] = [{
      id: `evidence-${response.id}`,
      source: csatData.campaignName || 'CSAT Survey',
      type: 'verbatim',
      text: response.comment,
      value: response.score,
      unit: 'csat-score',
      collected_at: response.date
    }]

    const source: InsightSource = {
      type: 'csat',
      sourceId: csatData.id,
      sourceName: csatData.campaignName || 'CSAT Survey',
      autoGenerated: true
    }

    return {
      tempId: `temp-${Date.now()}-${Math.random()}`,
      journey_id: this.journeyId,
      title,
      summary: response.comment || '',
      severity,
      evidence,
      source,
      suggestedPlacements: [],
      autoGenerated: true
    }
  }

  /**
   * Generate insights from CES (Customer Effort Score) data
   * Focus on high effort scores (5-7)
   */
  async generateFromCES(cesData: CESData): Promise<GeneratedInsight[]> {
    const insights: GeneratedInsight[] = []

    // Process high effort scores (5-7) - indicates friction
    const highEffort = cesData.responses.filter(r => r.score >= 5 && r.comment)
    for (const response of highEffort) {
      if (!response.comment) continue

      const severity = response.score === 7 ? 5 : response.score === 6 ? 4 : 3

      const insight = this.createInsightFromCESResponse(
        response,
        cesData,
        severity as 1 | 2 | 3 | 4 | 5
      )
      insights.push(insight)
    }

    return insights
  }

  private createInsightFromCESResponse(
    response: CESResponse,
    cesData: CESData,
    severity: 1 | 2 | 3 | 4 | 5
  ): GeneratedInsight {
    const title = this.extractTitle(response.comment || '', response.task)

    const evidence: Evidence[] = [{
      id: `evidence-${response.id}`,
      source: cesData.campaignName || 'CES Survey',
      type: 'verbatim',
      text: response.comment,
      value: response.score,
      unit: 'ces-score',
      collected_at: response.date
    }]

    const source: InsightSource = {
      type: 'ces',
      sourceId: cesData.id,
      sourceName: cesData.campaignName || 'CES Survey',
      autoGenerated: true
    }

    return {
      tempId: `temp-${Date.now()}-${Math.random()}`,
      journey_id: this.journeyId,
      title,
      summary: response.comment || response.task || '',
      severity,
      evidence,
      source,
      suggestedPlacements: [],
      autoGenerated: true
    }
  }

  /**
   * Generate insights from interview data
   * Process highlights that are tagged as pain-points or negative
   */
  async generateFromInterview(interviewData: InterviewData): Promise<GeneratedInsight[]> {
    const insights: GeneratedInsight[] = []

    // Process pain points and negative highlights
    const relevantHighlights = interviewData.highlights.filter(h =>
      h.category === 'pain-point' || h.category === 'negative' || h.category === 'insight'
    )

    for (const highlight of relevantHighlights) {
      const severity = this.determineInterviewSeverity(highlight)

      const evidence: Evidence[] = [{
        id: `evidence-${highlight.id}`,
        source: interviewData.interviewName || 'User Interview',
        type: 'verbatim',
        text: highlight.quote,
        collected_at: interviewData.conductedAt
      }]

      const source: InsightSource = {
        type: 'interview',
        sourceId: interviewData.id,
        sourceName: interviewData.interviewName || 'User Interview',
        autoGenerated: true
      }

      insights.push({
        tempId: `temp-${Date.now()}-${Math.random()}`,
        journey_id: this.journeyId,
        title: this.extractTitle(highlight.quote),
        summary: highlight.quote,
        severity,
        evidence,
        source,
        suggestedPlacements: [],
        autoGenerated: true
      })
    }

    return insights
  }

  /**
   * Generate insights from survey data
   * Extract open-ended responses that indicate issues
   */
  async generateFromSurvey(surveyData: SurveyData): Promise<GeneratedInsight[]> {
    const insights: GeneratedInsight[] = []

    // Process each response
    for (const response of surveyData.responses) {
      // Look for open-ended text answers
      const textAnswers = response.answers.filter(a =>
        typeof a.answer === 'string' && a.answer.length > 20
      )

      for (const answer of textAnswers) {
        if (typeof answer.answer !== 'string') continue

        const evidence: Evidence[] = [{
          id: `evidence-${response.id}-${answer.questionId}`,
          source: surveyData.surveyName || 'Survey',
          type: 'verbatim',
          text: answer.answer,
          collected_at: response.date
        }]

        const source: InsightSource = {
          type: 'survey',
          sourceId: surveyData.id,
          sourceName: surveyData.surveyName || 'Survey',
          autoGenerated: true
        }

        // Default to medium severity for surveys (needs manual review)
        insights.push({
          tempId: `temp-${Date.now()}-${Math.random()}`,
          journey_id: this.journeyId,
          title: this.extractTitle(answer.answer),
          summary: answer.answer,
          severity: 3,
          evidence,
          source,
          suggestedPlacements: [],
          autoGenerated: true
        })
      }
    }

    return insights
  }

  /**
   * Use AI to extract better title and summary from feedback
   * Falls back to simple extraction if AI fails
   */
  private async extractInsightWithAI(
    feedback: string,
    context?: { type: string; score?: number }
  ): Promise<{ title: string; summary: string; severity: 1 | 2 | 3 | 4 | 5; method: 'ai' | 'keyword' }> {
    try {
      // Prepare journey map context if available
      let journeyContext = ''
      if (this.journeyMap) {
        const stages = this.journeyMap.stages.map(s => s.name).join(' → ')
        const rows = this.journeyMap.rows.map(r => r.category).join(', ')
        journeyContext = `

Journey Map Context:
- Stages: ${stages}
- Row Categories: ${rows}
- Use language and terminology that fits this journey structure`
      }

      const prompt = `You are analyzing customer feedback for a Customer Experience (CX) journey map.

Extract a concise, actionable insight from this feedback.

Feedback: "${feedback}"
${context?.type ? `Type: ${context.type}` : ''}
${context?.score !== undefined ? `Score: ${context.score}` : ''}${journeyContext}

Return JSON with:
- title: A short, actionable title (max 60 characters) that captures the main issue
- summary: A clear 1-2 sentence summary of the problem
- severity: Rate 1-5 where 5 is critical and 1 is minor

Consider:
- What is the customer pain point?
- How urgent/important is this issue?
- Can this be improved in the journey?
${this.journeyMap ? '- Which stage of the journey does this relate to?' : ''}

Return ONLY valid JSON, no markdown.`

      const response = await callOpenRouter([
        {
          role: 'user',
          content: prompt
        }
      ], {
        temperature: 0.3,
        maxTokens: 500
      })

      const result = parseAIJsonResponse<{
        title: string
        summary: string
        severity: number
      }>(response)

      // Ensure severity is in range 1-5
      const severity = Math.max(1, Math.min(5, Math.round(result.severity))) as 1 | 2 | 3 | 4 | 5

      return {
        title: result.title.substring(0, 60),
        summary: result.summary,
        severity,
        method: 'ai'
      }
    } catch (error) {
      console.warn('AI extraction failed, using fallback:', error)
      // Fallback to simple extraction
      return {
        title: this.extractTitle(feedback, context?.type),
        summary: feedback,
        severity: context?.score ? this.scoreToSeverity(context.score) : 3,
        method: 'keyword'
      }
    }
  }

  /**
   * Convert numeric score to severity (helper for fallback)
   */
  private scoreToSeverity(score: number): 1 | 2 | 3 | 4 | 5 {
    if (score <= 2) return 5
    if (score <= 4) return 4
    if (score <= 6) return 3
    if (score <= 8) return 2
    return 1
  }

  /**
   * Extract a concise title from feedback text
   * Max 60 characters, tries to summarize the main point
   */
  private extractTitle(text: string, context?: string): string {
    if (!text) return 'Customer feedback'

    // Clean and trim
    let title = text.trim()

    // Take first sentence if multiple
    const firstSentence = title.split(/[.!?]/)[0]
    if (firstSentence.length > 0 && firstSentence.length < 80) {
      title = firstSentence
    }

    // Truncate if too long
    if (title.length > 60) {
      title = title.substring(0, 57) + '...'
    }

    // If we have context (like CES task), prepend it
    if (context && title.length < 40) {
      title = `${context}: ${title}`
      if (title.length > 60) {
        title = title.substring(0, 57) + '...'
      }
    }

    return title
  }

  /**
   * Calculate severity from NPS score
   * 0-4: Critical (5)
   * 5-6: High (4)
   * 7-8: Medium (3)
   */
  private calculateNPSSeverity(score: number): 1 | 2 | 3 | 4 | 5 {
    if (score <= 4) return 5
    if (score <= 6) return 4
    if (score <= 8) return 3
    return 2
  }

  /**
   * Determine severity from interview highlight
   */
  private determineInterviewSeverity(highlight: InterviewHighlight): 1 | 2 | 3 | 4 | 5 {
    if (highlight.category === 'pain-point') return 4
    if (highlight.category === 'negative') return 3
    return 3 // Default for insights
  }
}

/**
 * Helper function to generate insights from any research data type
 */
export async function generateInsightsFromResearch(
  journeyId: string,
  sourceType: 'nps' | 'csat' | 'ces' | 'interview' | 'survey',
  data: NPSData | CSATData | CESData | InterviewData | SurveyData,
  journeyMap?: JourneyMapData
): Promise<ImportResult> {
  try {
    const generator = new InsightGenerator(journeyId, journeyMap)
    let insights: GeneratedInsight[] = []

    switch (sourceType) {
      case 'nps':
        insights = await generator.generateFromNPS(data as NPSData)
        break
      case 'csat':
        insights = await generator.generateFromCSAT(data as CSATData)
        break
      case 'ces':
        insights = await generator.generateFromCES(data as CESData)
        break
      case 'interview':
        insights = await generator.generateFromInterview(data as InterviewData)
        break
      case 'survey':
        insights = await generator.generateFromSurvey(data as SurveyData)
        break
    }

    return {
      success: true,
      insights,
      warnings: insights.length === 0 ? ['No insights could be generated from this data'] : []
    }
  } catch (error) {
    return {
      success: false,
      insights: [],
      errors: [error instanceof Error ? error.message : 'Unknown error occurred']
    }
  }
}
